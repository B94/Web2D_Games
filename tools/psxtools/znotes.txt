PlayStation ONE EXE header
	00  8  "PS-X EXE"
	10  4  mips start()
	18  4  mips ram
	1c  4  mips size
	30  4  init stack
	# RAM 80000000-80200000 (2 MB , first 10000 = bios)

Saturn ISO boot header
	00   16  "SEGA SEGASATURN"
	10   16  "SEGA TP T-" + version
	20   10  Game ID
	2a    6  Game Version
	30    8  yyyymmdd
	38    8  "CD-1/1"
	40   16  "J"
	50   16  "J"
	60  128  Game Title
	e0    4  sh-4 start()
	e8    4  init stack master
	ec    4  init stack slave
	f0    4  sh-4 ram
	f4    4  sh-4 size
	# RAM 6002000-6100000 (~1 MB)

Nintendo DS ROM header
	00  12  Game Title
	0c   4  Game ID (NTR-xxxx)
	20   4  arm9.bin offset
	24   4  arm9 start()
	28   4  arm9 ram
	2c   4  arm9.bin size
	30   4  arm7.bin offset
	34   4  arm7 start()
	38   4  arm7 ram
	3c   4  arm7.bin size
	40   4  file name table offset
	44   4  file name table size
	48   4  file allocation table offset
	4c   4  file allocation table size
	50   4  y9.bin offset
	54   4  y9.bin size
	58   4  y7.bin offset
	5c   4  y7.bin size
	80   4  ROM size
	84   4  header.bin size
	# RAM 2000000-24000000 (4 MB)

info.sonicretro.org/SPG:Solid_Tiles

	The Mega Drive games use angles in hex,
	$00 through $FF,
	meaning that there are only 256 divisions of a circle,
	not 360 like we're used to.
	Worse, the direction is anti-clockwise compared to other languages like GML,
	so $20 isn't 45 degree like it should be - it's 315 degree.

	In order to convert the original hex angles into angles you can use in GML,
	use this calculation (rendered here in pseudo-code):

	return (256-hex_angle)*1.40625;

gamedev.stackexchange.com/questions/86755/how-to-calculate-corner-positions-marks-of-a-rotated-tilted-rectangle

	// cx, cy - center of square coordinates
	// x, y - coordinates of a corner point of the square
	// theta is the angle of rotation
	// translate point to origin
	float tempX = x - cx;
	float tempY = y - cy;

	// now apply rotation
	float rotatedX = tempX*cos(theta) - tempY*sin(theta);
	float rotatedY = tempX*sin(theta) + tempY*cos(theta);

	// translate back
	x = rotatedX + cx;
	y = rotatedY + cy;

stackoverflow.com/questions/20530949/2d-rotation-is-leaving-holes

	The way to avoid having gaps in between valid pixels is to work backwards.
	Rather than taking each pixel in the source image and moving it
	to its place in the destination image by rotating the pixel to a new position,
	you should iterate through each pixel in the destination image
	and figure out which pixel in the source image it corresponds to.

	To do this you just need to go through each pixel (xdraw,ydraw)
	in the destination image and apply the inverse rotation
	to get the corresponding pixel (xorig,yorig) in the source image.

forum.yoyogames.com/index.php?threads/sprites-got-jagged-when-rotating.5258/

	The program is trying to rotate the pixels,
	it doesn't know that the circle is a circle,
	all it knows is to rotate the pixels,
	so it becomes jagged.
	this also happens when rotating most sprites in an image editor,
	not much can be fixed about it.

	You other option is to use effects to blur the edges like anti-aliasing and interpolation
	but those effects will also look bad the more low res they are.

docs.gimp.org/en/gimp-concepts-layer-modes.html
	For each pixel in the upper (Mask) and lower (Image) layer,
	to form the E resulting pixel's color.

	layer mode "Normal"
		E = M
	layer mode "Multiply"
		E = (M * I) / 255
	layer mode "Divide"
		E = (256 * I) / (M + 1)
	layer mode "Screen"
		E = (255 - M) * (255 - I)
		E = 255 - (E / 255)
	layer mode "Overlay"
		E = (2 * M) / 255
		E = I + E * (255 - I)
		E = (I / 255) * E
	layer mode "Dodge"
		E = (256 * I) / (255 - M + 1)
	layer mode "Burn"
		E = (255 - I) / (M + 1)
		E = 255 - (256 * E)
	layer mode "Hard Light" M > 128
		E = 255 - 2 * (M - 128)
		E = E * (255 - I)
		E = 255 - (E / 256)
	layer mode "Hard Light" M <= 128
		E = (2 * M * I) / 256
	layer mode "Soft Light"
		RS = (Screen)E
		E = (255 - I) * M + RS
		E = (E / 255) * I
	layer mode "Grain extract"
		E = I - M + 128
	layer mode "Grain merge"
		E = I + M + 128
	layer mode "Difference"
		E = |I - M|
	layer mode "Addition"
		E = min(M + I , 255)
	layer mode "Subtraction"
		E = max(I - M , 0)
	layer mode "Darken only"
		E = min(M , I)
	layer mode "Lighten only"
		E = max(M , I)

stackoverflow.com/questions/12011081/alpha-blending-2-rgba-colors-in-c

	int blend(unsigned char result[4], unsigned char fg[4], unsigned char bg[4])
	{
		unsigned int alpha = fg[3] + 1;
		unsigned int inv_alpha = 256 - fg[3];
		result[0] = (unsigned char)((alpha * fg[0] + inv_alpha * bg[0]) >> 8);
		result[1] = (unsigned char)((alpha * fg[1] + inv_alpha * bg[1]) >> 8);
		result[2] = (unsigned char)((alpha * fg[2] + inv_alpha * bg[2]) >> 8);
		result[3] = 0xff;
	}

stackoverflow.com/questions/9014729/manually-alpha-blending-an-rgba-pixel-with-an-rgb-pixel

	A typical "Over" blend is done in the following way:

		outputRed = (foregroundRed * foregroundAlpha) + (backgroundRed * (1.0 - foregroundAlpha));

	And then repeating for the blue and green channels.
	Do this for every pixel.

stackoverflow.com/questions/13002979/how-to-calculate-rotation-angle-from-rectangle-points

	If the shape is not rotated more than 90 degree,
	you can use the tanget ratio of a right angle triangle:

		var rotationRadians = Math.atan((x1 - x4) / (y1 - y4));
		var RAD2DEG = 180 / Math.PI;
		var rotationDegrees = rotationRadians * RAD2DEG;

	If the rotation is greater than 90 degree but less than 180 degree,
	you will need to add 180 degree:

		rotationDegrees += 180;

stackoverflow.com/questions/2992264/extracting-a-quadrilateral-image-to-a-rectangle

	Look up "quad to quad" transform, e.g. threeblindmiceandamonkey.
	A 3x3 transform on 2d homogeneous coordinates can transform
	any 4 points (a quad) to any other quad;
	conversely, any fromquad and toquad,
	such as the corners of your truck and a target rectangle,
	give a 3 x 3 transform.

stackoverflow.com/questions/299267/image-scaling-and-rotating-in-c-c

	The simplest way to scale is:
		dest[dx,dy] = src[ dx*src_width/dest_width , dy*src_height/dest_height ]
	For rotating, the src pixel location can be calculated using a rotation matrix:
		sx,sy = M(dx,dy)

	Mapping for a resize is easy:
		x' = x * (width' / width)
		y' = y * (height' / height)
	Mapping for rotation is only a little bit harder.
		x' = x * cos(a) + y * sin(a)
		y' = y * cos(a) - x * sin(a)

https://stackoverflow.com/questions/50255282/webgl2-has-anti-alias-automatically-built-in

	No, it's only a request, not a requirement.
	WebGL2 allows you to create antialiased renderbuffers with renderbufferStorageMultisample
	and resolve them using blitFramebuffer,
	a feature which was not available in WebGL1.
	Rendering to an antialiased framebuffer and then blitting that to the canvas
	is a way to force antialiasing, at least in WebGL2.

https://stackoverflow.com/questions/17224795/antialiasing-not-working-in-three-js

	Took me all afternoon to figure out on my system under chrome settings
	I didn't have checked "allow hardware acceleration when available",
	and viola, antialiasing is now working.

https://askubuntu.com/questions/40024/how-do-i-delete-a-directory-from-a-zip-file-using-a-bash-script

	If you want to delete all files from a specific dir, you could do this:
		zip --delete file.zip "assets/*"  "*.ext"

https://stackoverflow.com/questions/8985588/webgl-canvas-coordinates-to-3d-coords

	Basically if you want to draw in 2D use a 2D shader, don't try messing with a 3D shader.
	WebGL draws in clipspace so all you need to do is convert from pixels to clip space.
		attribute vec2 a_position;
		uniform   vec2 u_resolution;

		void main() {
			// convert positions from pixels to 0.0 to 1.0
			vec2 zeroToOne = a_position / u_resolution;

			// convert from 0->1 to 0->2
			vec2 zeroToTwo = zeroToOne * 2.0;

			// convert from 0->2 to -1->+1 (clipspace)
			vec2 clipSpace = zeroToTwo - 1.0;

			gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
		}

https://stackoverflow.com/questions/30445467/webgl-vs-css3d-for-large-scatter-plot-of-images

	The way game engines run fast is BY OPTIMIZING WHAT THEY DRAW!
	They draw as little as possible.
	They combine textures into text atlases,
	they combine meshes into large meshes.
	They get their draw calls down to a < 5000, often under 1000.

https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation
https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquationSeparate

	// void gl.blendEquation(mode);
	// void gl.blendEquationSeparate(modeRGB, modeAlpha);

	(default)
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc
https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFuncSeparate

	// BLEND_SRC_RGB, BLEND_SRC_ALPHA, BLEND_DST_RGB, and BLEND_DST_ALPHA

	// void gl.blendFunc(sfactor, dfactor);
	// void gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);

	No Blend (default)
		gl.blendFunc(gl.ONE, gl.ZERO);
		gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);

	Normal Blending
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

	Additive Blending
		gl.blendFunc(gl.ONE, gl.ONE);
		gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);

https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendColor

	// void gl.blendColor(red, green, blue, alpha);
